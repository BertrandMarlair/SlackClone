{"version":3,"sources":["../../src/utils/auth.js"],"names":["createTokens","user","secret","secret2","createToken","jwt","sign","_","pick","expiresIn","createRefreshToken","refreshTokens","token","refreshToken","models","SECRET","SECRET2","userId","id","decode","err","User","findOne","where","raw","refreshSecret","password","refreshTokenWithoutBearer","replace","verify","newToken","newRefreshToken","tryLogin","email","ok","errors","path","message","valid","bcrypt","compare","refreshTokenSecret"],"mappings":"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","sourcesContent":["import jwt from \"jsonwebtoken\";\nimport _ from \"lodash\";\nimport bcrypt from \"bcrypt\";\n\nexport const createTokens = async (user, secret, secret2) => {\n    const createToken = jwt.sign(\n        {\n            user: _.pick(user, [\"id\", \"isAdmin\", \"username\"]),\n        },\n        secret,\n        {\n            expiresIn: \"1h\",\n        },\n    );\n\n    const createRefreshToken = jwt.sign(\n        {\n            user: _.pick(user, \"id\"),\n        },\n        secret2,\n        {\n            expiresIn: \"7d\",\n        },\n    );\n\n    return [createToken, createRefreshToken];\n};\n\nexport const refreshTokens = async (\n    token,\n    refreshToken,\n    models,\n    SECRET,\n    SECRET2,\n) => {\n    let userId = 0;\n\n    try {\n        const {\n            user: {id},\n        } = jwt.decode(refreshToken);\n\n        userId = id;\n    } catch (err) {\n        return {};\n    }\n\n    if (!userId) {\n        return {};\n    }\n\n    const user = await models.User.findOne({\n        where: {id: userId},\n        raw: true,\n    });\n\n    if (!user) {\n        return {};\n    }\n\n    const refreshSecret = `${user.password}${SECRET2}`;\n    const refreshTokenWithoutBearer = refreshToken.replace(\"Bearer \", \"\");\n\n    try {\n        jwt.verify(refreshTokenWithoutBearer, refreshSecret);\n    } catch (err) {\n        return {};\n    }\n\n    const [newToken, newRefreshToken] = await createTokens(\n        user,\n        SECRET,\n        refreshSecret,\n    );\n\n    return {\n        token: newToken,\n        refreshToken: newRefreshToken,\n        user,\n    };\n};\n\nexport const tryLogin = async (email, password, models, SECRET, SECRET2) => {\n    const user = await models.User.findOne({\n        where: {email},\n        raw: true,\n    });\n\n    if (!user) {\n        // user with provided email not found\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: \"email\",\n                    message: \"Wrong email\",\n                },\n            ],\n        };\n    }\n\n    const valid = await bcrypt.compare(password, user.password);\n\n    if (!valid) {\n        // bad password\n        return {\n            ok: false,\n            errors: [\n                {\n                    path: \"password\",\n                    message: \"Wrong password\",\n                },\n            ],\n        };\n    }\n\n    const refreshTokenSecret = user.password + SECRET2;\n\n    const [token, refreshToken] = await createTokens(\n        user,\n        SECRET,\n        refreshTokenSecret,\n    );\n\n    return {\n        ok: true,\n        token,\n        refreshToken,\n    };\n};\n"],"file":"auth.js"}