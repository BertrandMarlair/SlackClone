{"version":3,"sources":["../../src/utils/auth.js"],"names":["createTokens","user","secret","secret2","createToken","jwt","sign","_","pick","expiresIn","createRefreshToken","refreshTokens","token","refreshToken","models","SECRET","SECRET2","userId","id","decode","err","User","findOne","where","raw","refreshSecret","password","refreshTokenWithoutBearer","replace","verify","newToken","newRefreshToken","tryLogin","email","ok","errors","path","message","valid","bcrypt","compare","refreshTokenSecret"],"mappings":"yIAAA,kEACA,sDACA,sD,mFAEO,KAAMA,CAAAA,YAAY,CAAG,MAAOC,IAAP,CAAaC,MAAb,CAAqBC,OAArB,GAAiC,CACzD,KAAMC,CAAAA,WAAW,CAAGC,sBAAIC,IAAJ,CAAS,CACrBL,IAAI,CAAEM,gBAAEC,IAAF,CAAOP,IAAP,CAAa,CAAC,IAAD,CAAO,SAAP,CAAkB,UAAlB,CAAb,CADe,CAAT,CAGhBC,MAHgB,CAGR,CACJO,SAAS,CAAE,IADP,CAHQ,CAApB,CAQA,KAAMC,CAAAA,kBAAkB,CAAGL,sBAAIC,IAAJ,CAAS,CAC5BL,IAAI,CAAEM,gBAAEC,IAAF,CAAOP,IAAP,CAAa,IAAb,CADsB,CAAT,CAGvBE,OAHuB,CAGd,CACLM,SAAS,CAAE,IADN,CAHc,CAA3B,CAQA,MAAO,CAACL,WAAD,CAAcM,kBAAd,CAAP,CACH,CAlBM,C,kCAoBA,KAAMC,CAAAA,aAAa,CAAG,MAAOC,KAAP,CAAcC,YAAd,CAA4BC,MAA5B,CAAoCC,MAApC,CAA4CC,OAA5C,GAAwD,CACjF,GAAIC,CAAAA,MAAM,CAAG,CAAb,CACA,GAAI,CACA,KAAM,CACFhB,IAAI,CAAE,CACFiB,EADE,CADJ,EAIFb,sBAAIc,MAAJ,CAAWN,YAAX,CAJJ,CAKAI,MAAM,CAAGC,EAAT,CACH,CAAC,MAAOE,GAAP,CAAY,CACV,MAAO,EAAP,CACH,CAED,GAAI,CAACH,MAAL,CAAa,CACT,MAAO,EAAP,CACH,CAED,KAAMhB,CAAAA,IAAI,CAAG,KAAMa,CAAAA,MAAM,CAACO,IAAP,CAAYC,OAAZ,CAAoB,CACnCC,KAAK,CAAE,CAAEL,EAAE,CAAED,MAAN,CAD4B,CAEnCO,GAAG,CAAE,IAF8B,CAApB,CAAnB,CAKA,GAAI,CAACvB,IAAL,CAAW,CACP,MAAO,EAAP,CACH,CAED,KAAMwB,CAAAA,aAAa,CAAI,GAAExB,IAAI,CAACyB,QAAS,GAAEV,OAAQ,EAAjD,CACA,KAAMW,CAAAA,yBAAyB,CAAGd,YAAY,CAACe,OAAb,CAAqB,SAArB,CAAgC,EAAhC,CAAlC,CACA,GAAI,CACAvB,sBAAIwB,MAAJ,CAAWF,yBAAX,CAAsCF,aAAtC,EACH,CAAC,MAAOL,GAAP,CAAY,CACV,MAAO,EAAP,CACH,CAED,KAAM,CAACU,QAAD,CAAWC,eAAX,EAA8B,KAAM/B,CAAAA,YAAY,CAACC,IAAD,CAAOc,MAAP,CAAeU,aAAf,CAAtD,CACA,MAAO,CACHb,KAAK,CAAEkB,QADJ,CAEHjB,YAAY,CAAEkB,eAFX,CAGH9B,IAHG,CAAP,CAKH,CAxCM,C,oCA0CA,KAAM+B,CAAAA,QAAQ,CAAG,MAAOC,KAAP,CAAcP,QAAd,CAAwBZ,MAAxB,CAAgCC,MAAhC,CAAwCC,OAAxC,GAAoD,CACxE,KAAMf,CAAAA,IAAI,CAAG,KAAMa,CAAAA,MAAM,CAACO,IAAP,CAAYC,OAAZ,CAAoB,CACnCC,KAAK,CAAE,CAAEU,KAAF,CAD4B,CAEnCT,GAAG,CAAE,IAF8B,CAApB,CAAnB,CAIA,GAAI,CAACvB,IAAL,CAAW,CAEP,MAAO,CACHiC,EAAE,CAAE,KADD,CAEHC,MAAM,CAAE,CAAC,CACLC,IAAI,CAAE,OADD,CAELC,OAAO,CAAE,aAFJ,CAAD,CAFL,CAAP,CAOH,CAED,KAAMC,CAAAA,KAAK,CAAG,KAAMC,iBAAOC,OAAP,CAAed,QAAf,CAAyBzB,IAAI,CAACyB,QAA9B,CAApB,CACA,GAAI,CAACY,KAAL,CAAY,CAER,MAAO,CACHJ,EAAE,CAAE,KADD,CAEHC,MAAM,CAAE,CAAC,CACLC,IAAI,CAAE,UADD,CAELC,OAAO,CAAE,gBAFJ,CAAD,CAFL,CAAP,CAOH,CAED,KAAMI,CAAAA,kBAAkB,CAAGxC,IAAI,CAACyB,QAAL,CAAgBV,OAA3C,CAEA,KAAM,CAACJ,KAAD,CAAQC,YAAR,EAAwB,KAAMb,CAAAA,YAAY,CAACC,IAAD,CAAOc,MAAP,CAAe0B,kBAAf,CAAhD,CAEA,MAAO,CACHP,EAAE,CAAE,IADD,CAEHtB,KAFG,CAGHC,YAHG,CAAP,CAKH,CArCM,C","sourcesContent":["import jwt from 'jsonwebtoken';\nimport _ from 'lodash';\nimport bcrypt from 'bcrypt';\n\nexport const createTokens = async (user, secret, secret2) => {\n    const createToken = jwt.sign({\n            user: _.pick(user, ['id', 'isAdmin', 'username']),\n        },\n        secret, {\n            expiresIn: '1h',\n        },\n    );\n\n    const createRefreshToken = jwt.sign({\n            user: _.pick(user, 'id'),\n        },\n        secret2, {\n            expiresIn: '7d',\n        },\n    );\n\n    return [createToken, createRefreshToken]\n};\n\nexport const refreshTokens = async (token, refreshToken, models, SECRET, SECRET2) => {\n    let userId = 0;\n    try {\n        const {\n            user: {\n                id\n            }\n        } = jwt.decode(refreshToken);\n        userId = id;\n    } catch (err) {\n        return {};\n    }\n\n    if (!userId) {\n        return {};\n    }\n\n    const user = await models.User.findOne({\n        where: { id: userId },\n        raw: true\n    });\n\n    if (!user) {\n        return {};\n    }\n\n    const refreshSecret = `${user.password}${SECRET2}`\n    const refreshTokenWithoutBearer = refreshToken.replace(\"Bearer \", \"\");\n    try {\n        jwt.verify(refreshTokenWithoutBearer, refreshSecret);\n    } catch (err) {\n        return {};\n    }\n\n    const [newToken, newRefreshToken] = await createTokens(user, SECRET, refreshSecret);\n    return {\n        token: newToken,\n        refreshToken: newRefreshToken,\n        user,\n    };\n};\n\nexport const tryLogin = async (email, password, models, SECRET, SECRET2) => {\n    const user = await models.User.findOne({\n        where: { email },\n        raw: true\n    });\n    if (!user) {\n        // user with provided email not found\n        return {\n            ok: false,\n            errors: [{\n                path: 'email',\n                message: 'Wrong email'\n            }]\n        }\n    }\n\n    const valid = await bcrypt.compare(password, user.password);\n    if (!valid) {\n        // bad password\n        return {\n            ok: false,\n            errors: [{\n                path: 'password',\n                message: 'Wrong password'\n            }]\n        }\n    }\n\n    const refreshTokenSecret = user.password + SECRET2\n\n    const [token, refreshToken] = await createTokens(user, SECRET, refreshTokenSecret);\n\n    return {\n        ok: true,\n        token,\n        refreshToken,\n    };\n};"],"file":"auth.js"}